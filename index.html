<!DOCTYPE html>
<html>
<head>
    <title>3D Black Hole Simulator</title>
    <meta charset="UTF-8">
    <style>
        body { font-family: Arial; background: #151826; color: #eee; }
        #controls { margin: 20px; background: #222; padding: 20px; border-radius: 8px; }
        label { font-weight: bold; }
        #renderCanvas { width: 100vw; height: 60vh; display: block; }
        .summary { margin-top: 12px; padding: 16px; background: #1e212d; border-radius: 6px; }
    </style>
</head>
<body>
    <h1>3D Black Hole Simulator</h1>
    <div id="controls">
        <form id="bhForm">
            <label>Black Hole Mass (kg):</label>
            <input type="number" id="mass" step="any" required>
            <br><label>Distance from Center (m):</label>
            <input type="number" id="radius" step="any" required>
            <br><label>Object Mass Nearby (kg):</label>
            <input type="number" id="objmass" step="any" required>
            <br><label>Object Height (m):</label>
            <input type="number" id="height" step="any" required>
            <br>
            <button type="submit">Simulate</button>
        </form>
        <div id="summary" class="summary"></div>
    </div>
    <div id="renderCanvas"></div>

    <!-- Three.js CDN -->
    <script src="https://unpkg.com/three@0.151.3/build/three.min.js"></script>
    <script>
        // Basic 3D scene
        let scene, camera, renderer, bhMesh, eventHorizonMesh;
        function init3D() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/(window.innerHeight*0.6), 0.1, 1e5);
            camera.position.set(0, 70, 150);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0x111122);
            renderer.setSize(window.innerWidth, window.innerHeight * 0.6);
            document.getElementById('renderCanvas').appendChild(renderer.domElement);

            // Black hole sphere
            bhMesh = new THREE.Mesh(
                new THREE.SphereGeometry(20, 64, 64),
                new THREE.MeshBasicMaterial({color: 0x222244})
            );
            scene.add(bhMesh);

            // Event horizon visualization (transparent)
            eventHorizonMesh = new THREE.Mesh(
                new THREE.SphereGeometry(22, 32, 32),
                new THREE.MeshBasicMaterial({color: 0xff2222, transparent: true, opacity: 0.3})
            );
            scene.add(eventHorizonMesh);

            // Some ambient stars
            for (let i=0; i<1000; i++) {
                const geo = new THREE.SphereGeometry(0.5,8,8);
                const star = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({color: 0xffffff}));
                star.position.set(
                    (Math.random()-0.5)*1000,
                    (Math.random()-0.5)*1000,
                    (Math.random()-0.5)*1000
                );
                scene.add(star);
            }

            animate();
        }
        function animate() {
            requestAnimationFrame(animate);
            bhMesh.rotation.y += 0.002;
            eventHorizonMesh.rotation.y += 0.002;
            renderer.render(scene, camera);
        }
        window.onload = init3D;

        // Physics calculation/visual API call
        document.getElementById('bhForm').onsubmit = async function(evt) {
            evt.preventDefault();
            const G = 6.674e-11, c = 3e8;
            let M = parseFloat(mass.value), r = parseFloat(radius.value), mobj = parseFloat(objmass.value), h = parseFloat(height.value);
            // Schwarzschild radius
            let r_s = (2*G*M)/(c**2);

            // Calculate escape velocity, etc. (client side, replace with API if needed)
            let escapevelocity = Math.sqrt((2*G*M)/r);
            let gravitationalacceleration = (G*M)/(r**2);
            let orbitalvelocity = Math.sqrt((G*M)/r);
            let gravitationalredshift = (1 / Math.sqrt(1 - (r_s / r))) - 1;
            let gravitationalpotentialenergy = -((G*mobj*M)/r);
            let acceleration = G*M/r**2*Math.sqrt(1-(r_s/r));
            let orbitalperiod = 2*Math.PI*Math.sqrt(r**3/(G*M));
            let tidalforce = (2*G*M*h)/(r**3);

            // Update visualization
            let scale = 22; // event horizon
            bhMesh.scale.set(r_s/scale, r_s/scale, r_s/scale);
            eventHorizonMesh.scale.set(r_s/scale, r_s/scale, r_s/scale);

            document.getElementById('summary').innerHTML = `
                <strong>Simulation Results:</strong><br>
                Schwarzschild radius: <b>${r_s.toExponential(4)}m</b><br>
                Escape velocity: <b>${escapevelocity.toExponential(4)}</b> m/s<br>
                Gravitational acceleration near BH: <b>${gravitationalacceleration.toExponential(4)}</b> m/s²<br>
                Orbital velocity: <b>${orbitalvelocity.toExponential(4)}</b> m/s<br>
                Gravitational redshift: <b>${gravitationalredshift.toExponential(4)}</b><br>
                Gravitational potential energy: <b>${gravitationalpotentialenergy.toExponential(4)}</b> J<br>
                Acceleration required to hover: <b>${acceleration.toExponential(4)}</b> m/s²<br>
                Orbital period: <b>${orbitalperiod.toExponential(4)}</b> s<br>
                Tidal force: <b>${tidalforce.toExponential(4)}</b> N<br>
            `;
        }
    </script>
</body>
</html>
